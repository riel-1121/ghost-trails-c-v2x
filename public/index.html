<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeFold CV2X</title>
    <style>
        html, body {
            background: #1a252f;
            margin: 0;
            padding: 10px;
            height: 100%;
            color: white;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="200"></canvas>

    <div style="margin-top: 10px;">
        <button onclick="exportData()">Export Data</button>
        <span id="status"></span>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Add error handling and immediate visual feedback
        if (!ctx) {
            document.body.innerHTML = '<h1 style="color: red;">Canvas not supported!</h1>';
        } else {
            // Set canvas background immediately
            ctx.fillStyle = '#1a252f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Loading TimeFold CV2X...', 250, 100);
        }
        
        let packetCount = 0;
        let ghostsAlive = false;
        let packetLog = [];
        let lastGhostCount = 0;
        let denmIndex = 0;
        const realDenm = [
            "DENM 0001 | 0.0s | 49.282147 -123.120451 | Cause=SlipperyRoad Sub=Ice",
            "DENM 0002 | 0.1s | 49.282148 -123.120452 | Cause=SlipperyRoad Sub=Ice",
            "DENM 0003 | 0.2s | 49.282149 -123.120453 | Cause=SlipperyRoad Sub=Ice",
            "DENM 0004 | 1.2s | 49.282300 -123.120600 | Cause=SlipperyRoad Sub=Ice",
            "DENM 0005 | 8.7s | 49.282500 -123.120800 | Cause=SlipperyRoad Sub=Ice"
        ];
        const latencyLines = [
            "50 m  → 8 ms",
            "100 m → 16 ms",
            "300 m → 32 ms",
            "500 m → 48 ms"
        ];

        // Sample data for demonstration
        let sampleData = {
            vehicles: [
                { x: 100, y: 25, color: 'red', type: 'lead' },    // Left lane
                { x: 200, y: 50, color: 'blue', type: 'follower' }, // Center lane
                { x: 300, y: 75, color: 'green', type: 'follower' } // Right lane
            ],
            ghosts: [], // Start with no ghosts - they appear when hazards are detected
            icePosition: 250, // Fixed position - vehicles move past this hazard
            highwayLength: 400,
            timeFoldStats: {
                fleetMemory: 42,
                maxIterations: 1000
            }
        };

        // Start demo animation with proper frame timing
        let lastTime = 0;
        const targetFPS = 30; // Limit to 30 FPS for performance
        const frameInterval = 1000 / targetFPS;

        function animate(currentTime) {
            try {
                if (currentTime - lastTime >= frameInterval) {
                    if (ghostsAlive) packetCount++;
                    
                    // Animate vehicles moving forward
                    sampleData.vehicles.forEach(vehicle => {
                        vehicle.x += 2; // Move forward
                        if (vehicle.x > sampleData.highwayLength) {
                            vehicle.x = 0; // Reset to start
                        }
                    });
                    
                    // Age ghosts and remove expired ones
                    sampleData.ghosts = sampleData.ghosts.filter(ghost => {
                        ghost.age += 0.1;
                        return ghost.age <= 60; // Keep ghosts that haven't expired
                    });
                    
                    // Ice hazard stays stationary - vehicles move past it
                    
                    // Check for hazard detection - create ghosts when vehicles encounter ice
                    sampleData.vehicles.forEach(vehicle => {
                        const distanceToIce = Math.abs(vehicle.x - sampleData.icePosition);
                        if (distanceToIce < 20) { // Within 20 units of ice hazard
                        // Check if ghost already exists at this location (increased spacing)
                        const existingGhost = sampleData.ghosts.find(ghost => 
                            Math.abs(ghost.x - sampleData.icePosition) < 30
                        );                            if (!existingGhost) {
                                // Create new ghost warning
                                sampleData.ghosts.push({
                                    x: sampleData.icePosition,
                                    age: 0
                                });
                                
                                // Add DENM packet to log
                                const hex = realDenm[denmIndex % realDenm.length];
                                packetLog.push(hex);
                                denmIndex++;
                                if (packetLog.length > 20) packetLog.shift();
                                ghostsAlive = true;
                            }
                        }
                    });
                    
                    draw(sampleData);
                    lastTime = currentTime;
                }
                requestAnimationFrame(animate);
            } catch (error) {
                console.error('Animation error:', error);
                ctx.fillStyle = 'red';
                ctx.font = '16px Arial';
                ctx.fillText('Animation Error: ' + error.message, 10, 30);
            }
        }
        
        requestAnimationFrame(animate);

        function draw(data, fullData = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background buildings
            ctx.fillStyle = 'rgba(100, 100, 120, 0.3)';
            ctx.fillRect(0, 0, 200, canvas.height);
            ctx.fillRect(canvas.width - 200, 0, 200, canvas.height);

            // Draw Tesla road with proper perspective (converging lanes)
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.4)'; // faint cyan lanes
            ctx.lineWidth = 6;
            const roadTop = canvas.height * 0.3; // 60
            const roadBottom = canvas.height; // 200
            const roadWidthTop = canvas.width * 0.2; // Narrow at top
            const roadWidthBottom = canvas.width * 0.8; // Wide at bottom
            const centerX = canvas.width / 2;

            // Draw converging lane lines
            for (let i = -2; i <= 2; i++) {
                const topX = centerX + (i * roadWidthTop / 4);
                const bottomX = centerX + (i * roadWidthBottom / 4);
                ctx.beginPath();
                ctx.moveTo(topX, roadTop);
                ctx.lineTo(bottomX, roadBottom);
                ctx.stroke();
            }

            // Yellow center line (dashed, converging)
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(centerX, roadTop);
            ctx.lineTo(centerX, roadBottom);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw ice
            ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
            const iceProgress = data.icePosition / data.highwayLength;
            const iceY = roadTop + iceProgress * (roadBottom - roadTop);
            ctx.fillRect(centerX - 10, iceY - 10, 20, 20);

            // Text overlays
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Ghost Trails — C-V2X hazard broadcast', 15, 35);
            ctx.font = '14px Arial';
            ctx.fillText('Red ghost = black ice detected — fades over 60 seconds', 15, 75);

            // Packet counter top-right with TimeFold stats
            ctx.fillStyle = 'cyan';
            ctx.font = '12px Consolas';
            ctx.fillText(`DENM pkts: ${packetCount}`, canvas.width - 200, 15);
            if (data.timeFoldStats) {
                ctx.fillText(`Fleet Memory: ${data.timeFoldStats.fleetMemory}`, canvas.width - 200, 30);
                ctx.fillText(`Max Iterations: ${data.timeFoldStats.maxIterations}`, canvas.width - 200, 45);
            }

            // Comparative metrics if available
            if (fullData && fullData.comparison) {
                ctx.fillStyle = 'lime';
                ctx.fillText(`Collision Reduction: ${fullData.comparison.collisionReduction.toFixed(1)}%`, canvas.width - 200, 60);
                ctx.fillText(`Avoidance Efficiency: ${fullData.comparison.avoidanceEfficiency.toFixed(2)}x`, canvas.width - 200, 75);
                ctx.fillText(`Comm Overhead: ${fullData.comparison.communicationOverhead.toFixed(2)}x`, canvas.width - 200, 90);
            }

            // Draw vehicles positioned on the perspective road
            data.vehicles.forEach(vehicle => {
                // Position along the road (0 = far away, 1 = close)
                const progress = vehicle.x / data.highwayLength;
                const roadY = roadTop + progress * (roadBottom - roadTop);

                // Road width at this distance (linear interpolation)
                const roadWidthAtY = roadWidthTop + (roadWidthBottom - roadWidthTop) * ((roadY - roadTop) / (roadBottom - roadTop));

                // Lane position within the road - map y values to lane positions
                // y=0: far left, y=50: center, y=100: far right
                const laneIndex = Math.round((vehicle.y / 100) * 4) - 2; // Map 0-100 to -2 to 2
                const laneOffset = laneIndex * (roadWidthAtY / 4); // Use same spacing as road lanes
                const x = centerX + laneOffset;

                const angle = -Math.PI / 2; // Point up (towards viewer)
                const tipX = x + 8 * Math.cos(angle);
                const tipY = roadY + 8 * Math.sin(angle);
                const leftX = x - 6 * Math.cos(angle - 2.8);
                const leftY = roadY - 6 * Math.sin(angle - 2.8);
                const rightX = x - 6 * Math.cos(angle + 2.8);
                const rightY = roadY - 6 * Math.sin(angle + 2.8);
                ctx.fillStyle = vehicle.color;
                ctx.beginPath();
                ctx.moveTo(tipX, tipY);
                ctx.lineTo(leftX, leftY);
                ctx.lineTo(rightX, rightY);
                ctx.closePath();
                ctx.fill();
            });

            // Draw packet log
            ctx.fillStyle = 'limegreen';
            ctx.font = '9px Consolas';
            for (let i = 0; i < packetLog.length; i++) {
                ctx.fillText(packetLog[packetLog.length - 1 - i], 10, canvas.height - 60 - i * 18);
            }

            // Draw latency log
            ctx.fillStyle = 'yellow';
            for (let i = 0; i < latencyLines.length; i++) {
                ctx.fillText(latencyLines[i], canvas.width - 150, canvas.height - 60 - i * 18);
            }

            // Draw range ring around lead car
            const lead = data.vehicles.find(v => v.type === 'lead');
            if (lead) {
                const progress = lead.x / data.highwayLength;
                const broadcasterY = roadTop + progress * (roadBottom - roadTop);
                const roadWidthAtY = roadWidthTop + (roadWidthBottom - roadWidthTop) * ((broadcasterY - roadTop) / (roadBottom - roadTop));
                const laneIndex = Math.round((lead.y / 100) * 4) - 2;
                const laneOffset = laneIndex * (roadWidthAtY / 4);
                const broadcasterX = centerX + laneOffset;
                const rangeMeters = 500;
                const metersPerPixel = 2.0;
                const radiusPixels = rangeMeters / metersPerPixel;
                if (broadcasterX + radiusPixels < canvas.width && broadcasterX - radiusPixels > 0) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.ellipse(broadcasterX, broadcasterY, radiusPixels, radiusPixels, 0, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
                    ctx.font = '10px Arial';
                    ctx.fillText('500 m', broadcasterX - radiusPixels - 50, broadcasterY - 10);
                }
                // Blue ego-glow
                ctx.strokeStyle = 'rgba(0, 191, 255, 0.4)';
                ctx.lineWidth = 20;
                ctx.beginPath();
                ctx.ellipse(broadcasterX, broadcasterY, 60, 60, 0, 0, 2 * Math.PI);
                ctx.stroke();
            }

            // Draw ghosts
            data.ghosts.forEach(ghost => {
                const progress = ghost.x / data.highwayLength;
                const py = roadTop + progress * (roadBottom - roadTop);
                const px = centerX;
                const age = ghost.age;
                let pulse = 0;
                if (age < 4) {
                    pulse = 0.5 + 0.5 * Math.sin(age * 8);
                }
                const alpha = 255 * (1 - age / 60);
                ctx.strokeStyle = `rgba(255, 80, 80, ${alpha / 255})`;
                ctx.lineWidth = 12 + pulse * 8;
                ctx.beginPath();
                ctx.ellipse(px, py, 50, 50, 0, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Arial';
                ctx.fillText('!', px - 18, py + 18);
                const secondsLeft = Math.max(0, 60 - Math.floor(age));
                const minutes = Math.floor(secondsLeft / 60);
                const secs = secondsLeft % 60;
                const timer = `${minutes}:${secs < 10 ? '0' + secs : secs}`;
                ctx.fillStyle = 'cyan';
                ctx.font = 'bold 28px Consolas';
                ctx.fillText(timer, px - 25, py + 50);
            });

            // Latency label bottom-right
            ctx.fillStyle = 'cyan';
            ctx.font = 'bold 14px Consolas';
            ctx.textAlign = 'right';
            ctx.fillText('< 50 ms edge-to-edge', canvas.width - 15, canvas.height - 15);

            // Spec bar bottom
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('C-V2X PC5 • 10Hz • 500m • <48ms • 1.2kB/s • 100% P2P', 10, canvas.height - 10);
        }

        function exportData() {
            const status = document.getElementById('status');
            status.textContent = 'Exporting...';

            // Simple CSV export of current metrics
            const csv = `TimeFold Stats\nCollision Reduction: ${document.querySelector('canvas').getAttribute('data-collision-reduction') || 'N/A'}\nFleet Memory: ${document.querySelector('canvas').getAttribute('data-fleet-memory') || 'N/A'}\n`;

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'timefold-data.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            status.textContent = 'Data exported!';
            setTimeout(() => status.textContent = '', 3000);
        }
    </script>
</body>
</html>